kopackage com.epay.merchant.service;

import com.epay.merchant.dao.AlertMasterDao;
import com.epay.merchant.dto.AlertManagementDto;
import com.epay.merchant.dto.AlertMasterDto;
import com.epay.merchant.util.DateTimeUtils;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@RequiredArgsConstructor
@Component
public class AccountExpirationScheduler {

    private final AlertMasterDao alertMasterDao;
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    @Scheduled(cron = "${scheduled.cron.time}")
    public void checkAccountExpiry() {
        logger.info("Starting account expiry check.");
        List<AlertMasterDto> alertMasterDtoList = alertMasterDao.findAllAlertDaysByName("Account Expiry");

        if (alertMasterDtoList.isEmpty()) {
            logger.info("No alert days found for 'Account Expiry'. Exiting.");
            return;
        }

        Map<String, Long> dayAndTimeMap = createDayAndTimeMap(alertMasterDtoList);
        Map<String, AlertMasterDto> dayAndAlertMasterDtoMapped = mapAlertMasterDtoWithDay(alertMasterDtoList);
        Map<String, List<String>> mapOfAllMidsWithDay = alertMasterDao.findMidsForEachDay(dayAndTimeMap);

        if (mapOfAllMidsWithDay.isEmpty()) {
            logger.info("No MIDs found for the specified alert days. Exiting.");
            return;
        }

        List<AlertManagementDto> alertManagementDtoList = createAlertManagementDtoList(dayAndAlertMasterDtoMapped, mapOfAllMidsWithDay);
        alertMasterDao.saveAllToAlertManagement(alertManagementDtoList);
        logger.info("Account expiry check completed. Saved {} alerts.", alertManagementDtoList.size());
    }

    private Map<String, Long> createDayAndTimeMap(List<AlertMasterDto> alertMasterDtoList) {
        return alertMasterDtoList.stream()
                .collect(Collectors.toMap(
                        AlertMasterDto::getValue,
                        dto -> DateTimeUtils.getFutureDateByDay(Integer.parseInt(dto.getUnit()))
                ));
    }

    private Map<String, AlertMasterDto> mapAlertMasterDtoWithDay(List<AlertMasterDto> alertMasterDtoList) {
        return alertMasterDtoList.stream()
                .collect(Collectors.toMap(AlertMasterDto::getValue, dto -> dto));
    }

    private List<AlertManagementDto> createAlertManagementDtoList(Map<String, AlertMasterDto> dayAndAlertMasterDtoMapped, Map<String, List<String>> mapOfAllMidsWithDay) {
        return mapOfAllMidsWithDay.entrySet().stream()
                .flatMap(entry -> entry.getValue().stream()
                        .map(mid -> AlertManagementDto.builder()
                                .alertId(dayAndAlertMasterDtoMapped.get(entry.getKey()).getId())
                                .mId(mid)
                                .description(dayAndAlertMasterDtoMapped.get(entry.getKey()).getDescription())
                                .build()))
                .collect(Collectors.toList());
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    @Query("SELECT mi.mid FROM MerchantInfo mi WHERE FUNCTION('TRUNC', TO_DATE(FUNCTION('TO_CHAR', mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = FUNCTION('TRUNC', TO_DATE(:validityEndTime / 1000, 'YYYY-MM-DD'))")
    List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);
Caused by: org.hibernate.query.sqm.produce.function.FunctionArgumentException: Parameter 1 of function 'trunc()' has type 'NUMERIC', but argument is of type 'java.sql.Date' mapped to 'DATE'


@Query("SELECT mi.mid FROM MerchantInfo mi " +
       "WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = " +
       "FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);



@Query("SELECT mi.mid FROM MerchantInfo mi " +
       "WHERE FUNCTION('TRUNC', FUNCTION('FROM_UNIXTIME', mi.validityEndTime / 1000)) = " +
       "FUNCTION('TRUNC', FUNCTION('FROM_UNIXTIME', :validityEndTime / 1000))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);

@Query("SELECT mi.mid FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', mi.validityEndTime / 1000, 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', :validityEndTime / 1000, 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);
-----
    @Query("SELECT mi.mId FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', mi.validityEndTime / 1000, 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', :validityEndTime / 1000, 'YYYY-MM-DD'))")
    List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);

Caused by: org.hibernate.query.sqm.produce.function.FunctionArgumentException: Parameter 1 of function 'to_date()' has type 'STRING', but argument is of type 'java.lang.Long' mapped to 'BIGINT'
-------------

@Query("SELECT mi.mId FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);


@Query(value = "SELECT mi.mId " +
               "FROM MerchantInfo mi " +
               "WHERE TRUNC(TO_DATE(TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = " +
               "      TRUNC(TO_DATE(TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))", 
       nativeQuery = true)
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);


select MID, TO_CHAR(DATE '1970-01-01' + NUMTODSINTERVAL(VALIDITY_END_TIME/1000, 'SECOND'),'DD-MON-YYYY') As validity_date from merchant_info Where TO_CHAR(DATE '1970-01-01' + NUMTODSINTERVAL(VALIDITY_END_TIME/1000, 'SECOND'),'DD-MON-YYYY') IN ('18-DEC-2025', '07-JAN-2025')


import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class DateConverter {
    public static String convertLongToDateString(Long timestamp) {
        if (timestamp == null) {
            throw new IllegalArgumentException("Timestamp cannot be null");
        }

        // Convert Long timestamp to LocalDate
        LocalDate date = Instant.ofEpochMilli(timestamp)
                                 .atZone(ZoneId.systemDefault())
                                 .toLocalDate();

        // Define the formatter for dd-MMM-yyyy
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

        // Format the date to the required format
        return date.format(formatter);
    }

    public static void main(String[] args) {
        Long sampleTimestamp = 1730943523109L; // Example timestamp
        String formattedDate = convertLongToDateString(sampleTimestamp);
        System.out.println("Formatted Date: " + formattedDate); // Output: 07-Jan-2025
    }
}


@Query("SELECT mi.mid, " +
       "TRUNC(DATE '1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) " +
       "FROM MerchantInfo mi " +
       "WHERE TRUNC(DATE '1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) IN :days")
List<Object[]> findMidsByExactDate(@Param("days") List<String> days);

Caused by: org.hibernate.query.SyntaxException: At 1:26 and token ''1970-01-01'', no viable alternative at input 'SELECT mi.mid, TRUNC(DATE *'1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) FROM MerchantInfo mi WHERE TRUNC(DATE '1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) IN :days' [SELECT mi.mid, TRUNC(DATE '1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) FROM MerchantInfo mi WHERE TRUNC(DATE '1970-01-01' + NUMTODSINTERVAL(mi.validityEndTime / 1000, 'SECOND')) IN :days]



INSERT INTO MERCHANT_BANK_ACCOUNT (
    ID,
    MID,
    ACCOUNT_HOLDER_NAME,
    ACCOUNT_UNIQUE_IDENTIFIER,
    ACCOUNT_TYPE,
    ACCOUNT_NUMBER,
    BANK_NAME,
    BRANCH_NAME,
    IFSC_CODE,
    IS_APPROVED,
    IS_PRIMARY,
    APPROVED_REJECTED_BY,
    REJECTED_REASON,
    APPROVED_REJECTED_ON,
    STATUS,
    CREATED_AT,
    CREATED_BY,
    UPDATED_BY,
    UPDATED_AT
) 
VALUES (
    SYS_GUID(), -- Automatically generates a unique ID
    'MID123456789', -- Replace with the MID from MERCHANT_INFO
    'John Doe', -- Account holder name
    'AUI12345', -- Unique account identifier
    'SAVINGS', -- Account type
    '1234567890123456', -- Account number
    'Bank of XYZ', -- Bank name
    'Main Branch', -- Branch name
    'IFSC0001234', -- IFSC code
    1, -- Is approved (0 for false, 1 for true)
    1, -- Is primary (0 for false, 1 for true)
    'AdminUser', -- Approved or rejected by
    'N/A', -- Rejection reason (if applicable)
    1672502400, -- Approved/rejected on (epoch time)
    'ACTIVE', -- Status
    1672502400, -- Created at (epoch time)
    'SystemAdmin', -- Created by
    'SystemAdmin', -- Updated by
    1672502400  -- Updated at (epoch time)
);
