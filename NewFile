package com.epay.merchant.service;

import com.epay.merchant.dao.AlertMasterDao;
import com.epay.merchant.dto.AlertManagementDto;
import com.epay.merchant.dto.AlertMasterDto;
import com.epay.merchant.util.DateTimeUtils;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@RequiredArgsConstructor
@Component
public class AccountExpirationScheduler {

    private final AlertMasterDao alertMasterDao;
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    @Scheduled(cron = "${scheduled.cron.time}")
    public void checkAccountExpiry() {
        logger.info("Starting account expiry check.");
        List<AlertMasterDto> alertMasterDtoList = alertMasterDao.findAllAlertDaysByName("Account Expiry");

        if (alertMasterDtoList.isEmpty()) {
            logger.info("No alert days found for 'Account Expiry'. Exiting.");
            return;
        }

        Map<String, Long> dayAndTimeMap = createDayAndTimeMap(alertMasterDtoList);
        Map<String, AlertMasterDto> dayAndAlertMasterDtoMapped = mapAlertMasterDtoWithDay(alertMasterDtoList);
        Map<String, List<String>> mapOfAllMidsWithDay = alertMasterDao.findMidsForEachDay(dayAndTimeMap);

        if (mapOfAllMidsWithDay.isEmpty()) {
            logger.info("No MIDs found for the specified alert days. Exiting.");
            return;
        }

        List<AlertManagementDto> alertManagementDtoList = createAlertManagementDtoList(dayAndAlertMasterDtoMapped, mapOfAllMidsWithDay);
        alertMasterDao.saveAllToAlertManagement(alertManagementDtoList);
        logger.info("Account expiry check completed. Saved {} alerts.", alertManagementDtoList.size());
    }

    private Map<String, Long> createDayAndTimeMap(List<AlertMasterDto> alertMasterDtoList) {
        return alertMasterDtoList.stream()
                .collect(Collectors.toMap(
                        AlertMasterDto::getValue,
                        dto -> DateTimeUtils.getFutureDateByDay(Integer.parseInt(dto.getUnit()))
                ));
    }

    private Map<String, AlertMasterDto> mapAlertMasterDtoWithDay(List<AlertMasterDto> alertMasterDtoList) {
        return alertMasterDtoList.stream()
                .collect(Collectors.toMap(AlertMasterDto::getValue, dto -> dto));
    }

    private List<AlertManagementDto> createAlertManagementDtoList(Map<String, AlertMasterDto> dayAndAlertMasterDtoMapped, Map<String, List<String>> mapOfAllMidsWithDay) {
        return mapOfAllMidsWithDay.entrySet().stream()
                .flatMap(entry -> entry.getValue().stream()
                        .map(mid -> AlertManagementDto.builder()
                                .alertId(dayAndAlertMasterDtoMapped.get(entry.getKey()).getId())
                                .mId(mid)
                                .description(dayAndAlertMasterDtoMapped.get(entry.getKey()).getDescription())
                                .build()))
                .collect(Collectors.toList());
    }
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

    @Query("SELECT mi.mid FROM MerchantInfo mi WHERE FUNCTION('TRUNC', TO_DATE(FUNCTION('TO_CHAR', mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = FUNCTION('TRUNC', TO_DATE(:validityEndTime / 1000, 'YYYY-MM-DD'))")
    List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);
Caused by: org.hibernate.query.sqm.produce.function.FunctionArgumentException: Parameter 1 of function 'trunc()' has type 'NUMERIC', but argument is of type 'java.sql.Date' mapped to 'DATE'


@Query("SELECT mi.mid FROM MerchantInfo mi " +
       "WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = " +
       "FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);



@Query("SELECT mi.mid FROM MerchantInfo mi " +
       "WHERE FUNCTION('TRUNC', FUNCTION('FROM_UNIXTIME', mi.validityEndTime / 1000)) = " +
       "FUNCTION('TRUNC', FUNCTION('FROM_UNIXTIME', :validityEndTime / 1000))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);

@Query("SELECT mi.mid FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', mi.validityEndTime / 1000, 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', :validityEndTime / 1000, 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);
-----
    @Query("SELECT mi.mId FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', mi.validityEndTime / 1000, 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', :validityEndTime / 1000, 'YYYY-MM-DD'))")
    List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);

Caused by: org.hibernate.query.sqm.produce.function.FunctionArgumentException: Parameter 1 of function 'to_date()' has type 'STRING', but argument is of type 'java.lang.Long' mapped to 'BIGINT'
-------------

@Query("SELECT mi.mId FROM MerchantInfo mi WHERE FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = FUNCTION('TRUNC', FUNCTION('TO_DATE', TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))")
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);


@Query(value = "SELECT mi.mId " +
               "FROM MerchantInfo mi " +
               "WHERE TRUNC(TO_DATE(TO_CHAR(mi.validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD')) = " +
               "      TRUNC(TO_DATE(TO_CHAR(:validityEndTime / 1000, 'YYYY-MM-DD'), 'YYYY-MM-DD'))", 
       nativeQuery = true)
List<String> findMidsByExactDate(@Param("validityEndTime") Long validityEndTime);


select MID, TO_CHAR(DATE '1970-01-01' + NUMTODSINTERVAL(VALIDITY_END_TIME/1000, 'SECOND'),'DD-MON-YYYY') As validity_date from merchant_info Where TO_CHAR(DATE '1970-01-01' + NUMTODSINTERVAL(VALIDITY_END_TIME/1000, 'SECOND'),'DD-MON-YYYY') IN ('18-DEC-2025', '07-JAN-2025')
